#!/usr/bin/env python3
"""
simulator.py

Takes as input a predicted NOE file (json format) generated by
the camera script predict_noes, and simulates a list of methyl-methyl
NOE conectivies. These are written out as a text file where each entry is
pair of methyl labels, and each entry indicates that the pair of methyls
listed experienced an NOE.
"""

import json
import time
import random
import argparse
import networkx as nx
import camera.sat as sat
import camera.hmqc as hmqc
import camera.params as params
import camera.structures as structures


class Vertex:
    """
    Object oriented representation of the vertex in the simulated noe network.
    This is an "imitation" of the Signature class from camera, designed to
    make the SAT code from the module reusable.
    """

    def __init__(self, label):
        """
        Construct self, essentially extracting only the assignment and color
        from the given label.
        """

        self.label = label
        self.color = [label[0]]
        self.options = []

    def is_geminal(self, other):
        """
        Return true if this vertex and another are a geminal pair, which can
        determined by looking at their labels.
        """
        if not isinstance(other, Vertex):
            return False

        elif self.label[0] == other.label[0]:
            if self.label[0] in ["L", "V"]:
                if self.label[:-1] == other.label[:-1]:
                    return True

        return False

    def __hash__(self):
        """
        Instructions for hashing a vertex object. We simply use the hash of
        its label.
        """
        return hash(self.label)

    def __eq__(self, other):
        """
        Instructions for testing equality between two Vertex objects. Two
        Vertex objects are equal if and only if they have the same label.
        """
        if not isinstance(other, Vertex):
            return False
        return self.label == other.label

    def __repr__(self):
        return self.label

    def nailed(self):
        """
        Return true if you have a non-empty set of options and your options
        contain methyls from only one residue.
        """

        if self.options:
            return len({m.seqid for m in self.options}) == 1


def get_args():
    """
    Parse command line arguments
    """

    parser = argparse.ArgumentParser(description=__doc__.strip())
    parser.add_argument("structure", help="structure file in json format")
    parser.add_argument("-r", "--radius", type=float, default=10,
                        help="maximum NOE distance")
    parser.add_argument("-p", "--observation-probability", type=float,
                        default=0.25, help="probability of removing an NOE")
    parser.add_argument("-o", "--output",
                        help="output file")
    parser.add_argument("-t", "--trials", type=int, default=10,
                        help="number of trials")

    params.FORCE_SV = True

    return parser.parse_args()


def main():
    """
    Main method for the script
    """

    args = get_args()

    # Read in the structure and remove all edges from the structure graph
    # if the endpoints do not come within the specified radius.

    structure = structures.load_structure(args.structure)

    # Create set of vertices from the nodes of the structure

    vertex_map = {m: Vertex(m.label) for m in structure.nodes()}
    vertices = {vertex_map[m] for m in structure.nodes()}

    # Initialize the fields we care about.

    sat_rt = []
    sample_rt = []

    sat_pn = []
    sample_pn = []

    sample_mistakes = []

    # Run the simulation X number of times

    for i in range(args.trials):

        print(f"\nRUNNING TRIAL {i + 1}\n")

        # Create graph.

        simgraph = nx.Graph()
        simgraph.add_nodes_from(vertices)

        # Iterate over pairs of strucutre edges

        for m, n in structure.edges():

            if structure[m][n]["distances"][0] < args.radius:
                if random.random() < args.observation_probability:
                    simgraph.add_edge(vertex_map[m], vertex_map[n],
                                      short=False)

        # Create CSP and run.

        t = time.time()

        formula = sat.IsomorphismCSP(simgraph, structure, edge_variables=False)

        support = formula.enumerate()
        hmqc.nailed_histogram(vertices, support)

        sat_time = time.time() - t
        nailed = len([v for v in vertices
                      if len({m.seqid for m in support[v]}) == 1])
        percent_nailed = nailed/len(vertices)

        for v in vertices:
            v.options = support[v]

        formula = sat.IsomorphismCSP(simgraph, structure)

        sat_rt.append(sat_time)
        sat_pn.append(percent_nailed)

        t = time.time()
        support = sat.gibbs_reduce(simgraph, structure, 1, 1000)
        hmqc.nailed_histogram(vertices, support)

        sample_time = time.time() - t
        nailed = len([v for v in vertices
                      if len({m.seqid for m in support[v]}) == 1])
        percent_nailed = nailed/len(vertices)

        sample_rt.append(sample_time)
        sample_pn.append(percent_nailed)
        sample_mistakes.append(len([v for v in vertices
                                    if v.label not in
                                    [m.label for m in support[v]]]))

        for v in vertices:
            v.options = []

    # Write out the final output

    output_dic = {"size": structure.number_of_nodes(),
                  "sat_time": sat_rt, "sat_nailed": sat_pn,
                  "sample_time": sample_rt, "sample_nailed": sample_pn,
                  "sample_mistakes": sample_mistakes}

    if args.output:
        with open(args.output, "w") as outf:
            json.dump(output_dic, outf)


if __name__ == "__main__":
    main()
